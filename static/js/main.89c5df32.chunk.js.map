{"version":3,"sources":["tdmClient.ts","jaicpClient.ts","dmColourChanger.ts","index.tsx"],"names":["startSession","tdmRequest","requestBody","fetch","Request","process","method","headers","body","JSON","stringify","then","data","json","tdmDmMachine","initial","states","init","on","CLICK","tdm","start","invoke","id","src","_ctx","_evt","onDone","target","actions","assign","sessionId","event","session","session_id","tdmUtterance","output","utterance","tdmPassivity","expected_passivity","tdmActions","cond","onError","utter","RECOGNISED","TIMEOUT","prompt","entry","send","context","type","value","ENDSPEECH","_evnt","some","item","name","ask","next","hypotheses","recResult","passivity","fail","sessionID","Math","random","toString","substr","jaicpDmMachine","ttsAgenda","jaicp","query","answer","sayColour","say","text","_context","dmMachine","welcome","stop","always","repaint","dm","REACT_APP_BACKEND","cancel","REGION","inspect","url","iframe","machine","Machine","asrtts","prepare","getAuthorizationToken","azureAuthorizationToken","idle","LISTEN","SPEAK","recognising","exit","_event","callback","_onReceive","ASRRESULT","noinput","delay","STARTSPEECH","inprogress","match","speaking","ttsUtterance","voices","tts","getVoices","voiceRe","RegExp","REACT_APP_TTS_VOICE","voice","find","v","test","onend","console","log","speak","error","TTS_ERROR","recLogResult","logIntent","nluData","intent","ReactiveButton","props","state","matches","className","style","animation","App","useMachine","devTools","recStart","asEffect","SpeechRecognition","startListening","continuous","language","REACT_APP_ASR_LANGUAGE","recStop","stopListening","ttsStart","ttsCancel","speechSynthesis","ponyfillTTS","ponyfill","createPonyfill","credentials","region","authorizationToken","SpeechSynthesisUtterance","ponyfillASR","AzureSpeechRecognition","createSpeechRecognitionPonyfill","applyPolyfill","asr","getRecognition","onresult","result","results","isFinal","transcript","confidence","current","onClick","rootElement","document","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.89c5df32.chunk.js","sourcesContent":["import { MachineConfig, send, assign } from \"xstate\";\n\nconst tdmEndpoint = process.env.REACT_APP_TDM_ENDPOINT || \"https://sourdough-for-dummies-orchestration-pipeline.eu2.ddd.tala.cloud/interact\"\nconst tdmSession = {\n    \"session\": {\n        \"my_frontend\": {\n            \"user_id\": \"speechstate\",\n            \"position\": {\n                \"latitude\": \"57.699188\",\n                \"longitude\": \"11.948313\"\n            }\n        }\n    }\n}\n\nconst startSession = {\n    \"version\": \"3.3\",\n    \"session\": tdmSession,\n    \"request\": {\n        \"start_session\": {}\n    }\n}\n\nconst passivity = (sessionId: string) => ({\n    \"version\": \"3.3\",\n    \"session\": { \"session_id\": sessionId },\n    \"request\": {\n        \"passivity\": {}\n    }\n})\n\nconst nlInput = (sessionId: string, hypotheses: Hypothesis[]) => ({\n    \"version\": \"3.3\",\n    \"session\": { \"session_id\": sessionId },\n    \"request\": {\n        \"natural_language_input\": {\n            \"modality\": \"speech\",\n            \"hypotheses\": hypotheses\n        }\n    }\n})\n\n\nconst tdmRequest = (requestBody: any) => (fetch(new Request(tdmEndpoint, {\n    method: 'POST',\n    headers: {\n        'Content-type': 'application/json'\n    },\n    body: JSON.stringify(requestBody)\n})).then(data => data.json()))\n\nexport const tdmDmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'tdm'\n            }\n        },\n        tdm: {\n            initial: 'start',\n            states: {\n                start: {\n                    invoke: {\n                        id: \"startSession\",\n                        src: (_ctx, _evt) => tdmRequest(startSession),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions: assign({\n                                    sessionId: (_ctx, event) => event.data.session.session_id,\n                                    tdmUtterance: (_ctx, event) => event.data.output.utterance,\n                                    tdmPassivity: (_ctx, event) => event.data.output.expected_passivity,\n                                    tdmActions: (_ctx, event) => event.data.output.actions,\n                                }),\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n                },\n                utter: {\n                    initial: 'prompt',\n                    on: {\n                        RECOGNISED: 'next',\n                        TIMEOUT: 'passivity'\n                    },\n                    states: {\n                        prompt: {\n                            entry: send((context: SDSContext) => ({\n                                type: \"SPEAK\", value: context.tdmUtterance\n                            })),\n                            on: {\n                                ENDSPEECH:\n                                    [\n                                        {\n                                            target: '#root.dm.init',\n                                            cond: (context, _evnt) => context.tdmActions.some((item: any) => item.name === 'EndSession')\n                                        },\n                                        { target: 'ask' }\n                                    ]\n\n                            }\n                        },\n                        ask: {\n                            entry: [\n                                send('LISTEN'),\n\n                            ],\n                        },\n                    }\n                },\n                next: {\n                    invoke: {\n                        id: \"nlInput\",\n                        src: (context, _evt) => tdmRequest(nlInput(context.sessionId, context.recResult)),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions:\n                                    assign({\n                                        tdmUtterance: (_ctx, event) => event.data.output.utterance,\n                                        tdmPassivity: (_ctx, event) => event.data.output.expected_passivity,\n                                        tdmActions: (_ctx, event) => event.data.output.actions,\n                                    }),\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n\n                },\n                passivity: {\n                    invoke: {\n                        id: \"passivity\",\n                        src: (context, _evt) => tdmRequest(passivity(context.sessionId)),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions: assign({\n                                    tdmUtterance: (_ctx, event) => event.data.output.utterance,\n                                    tdmPassivity: (_ctx, event) => event.data.output.expected_passivity,\n                                    tdmActions: (_ctx, event) => event.data.output.actions,\n                                }),\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n\n                },\n                fail: {}\n            },\n        },\n    },\n});\n","import { MachineConfig, send, assign } from \"xstate\";\n\nconst jaicpToken = 'NRBTzSQe:69ae9a334ee112ff9a006af3639ed243ec38e431'\nconst jaicpEndpoint = \"https://bot.jaicp.com/chatapi/\" + jaicpToken\n\nconst ID = function() {\n    // Math.random should be unique because of its seeding algorithm.\n    // Convert it to base 36 (numbers + letters), and grab the first 9 characters\n    // after the decimal. from https://gist.github.com/gordonbrander/2230317\n    return '_' + Math.random().toString(36).substr(2, 9);\n};\n\nconst sessionID = ID()\n\nconst jaicpRequest = (query: string) => (fetch(new Request(jaicpEndpoint, {\n    method: 'POST',\n    headers: {\n        'Content-type': 'application/json'\n    },\n    body: JSON.stringify({\n        \"clientId\": \"speechstate_\" + sessionID,\n        \"query\": query,\n    })\n})).then(data => data.json()))\n\n\nexport const jaicpDmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            entry: assign({\n                ttsAgenda: (_ctx, event) => \"Привет! Спроси меня что-нибудь.\"\n            }),\n            on: {\n                CLICK: 'jaicp'\n            }\n        },\n        jaicp: {\n            initial: 'utter',\n            states: {\n                utter: {\n                    initial: 'prompt',\n                    states: {\n                        prompt: {\n                            entry: send((context: SDSContext) => ({\n                                type: \"SPEAK\", value: context.ttsAgenda\n                            })),\n                            on: { ENDSPEECH: 'ask' },\n                        },\n                        ask: {\n                            entry: send('LISTEN')\n                        },\n                    },\n                    on: {\n                        RECOGNISED: 'next',\n                        // TIMEOUT: 'passivity'\n                    },\n                },\n                next: {\n                    invoke: {\n                        id: \"nlInput\",\n                        src: (context, _evt) => jaicpRequest(context.recResult[0].utterance),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions:\n                                    assign({\n                                        ttsAgenda: (_ctx, event) => event.data.data.answer,\n                                    }),\n                                cond: (_ctx, event) => event.data.data.answer !== \"\"\n                            },\n                            {\n                                target: '#root.dm.fail'\n                            }\n                        ],\n                        onError: { target: '#root.dm.fail' }\n                    }\n\n                },\n            },\n        },\n        fail: {}\n    },\n});\n","import { MachineConfig, send, Action } from \"xstate\";\n\n\nconst sayColour: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: `Repainting to ${context.recResult[0].utterance}`\n}))\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            initial: 'prompt',\n            on: {\n                RECOGNISED: [\n                    // { target: 'stop', cond: (context) => context.recResult === 'stop' },\n                    { target: 'repaint' }]\n            },\n            states: {\n                prompt: {\n                    entry: say(\"Tell me the colour\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {\n                    entry: send('LISTEN'),\n                },\n            }\n        },\n        stop: {\n            entry: say(\"Ok\"),\n            always: 'init'\n        },\n        repaint: {\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: sayColour,\n                    on: { ENDSPEECH: 'repaint' }\n                },\n                repaint: {\n                    entry: 'changeColour',\n                    always: '#root.dm.welcome'\n                }\n            }\n        }\n    }\n})\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, actions, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport SpeechRecognition from 'react-speech-recognition';\nimport { tdmDmMachine } from \"./tdmClient\";\nimport { jaicpDmMachine } from \"./jaicpClient\";\nimport { dmMachine } from \"./dmColourChanger\";\n\nimport createSpeechRecognitionPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/SpeechToText'\nimport createPonyfill from 'web-speech-cognitive-services/lib/SpeechServices';\n\nlet dm = dmMachine\nif (process.env.REACT_APP_BACKEND === 'TDM') {\n    dm = tdmDmMachine\n} else if (process.env.REACT_APP_BACKEND === 'JAICP') {\n    dm = jaicpDmMachine\n}\n\nconst { send, cancel } = actions\n\nconst TOKEN_ENDPOINT = 'https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken';\nconst REGION = 'northeurope';\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nconst defaultPassivity = 10\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dm\n        },\n        asrtts: {\n            initial: 'prepare',\n            states: {\n                prepare: {\n                    invoke: {\n                        id: \"getAuthorizationToken\",\n                        src: (_ctx, _evt) => getAuthorizationToken(),\n                        onDone: {\n                            actions: [\n                                assign((_context, event) => { return { azureAuthorizationToken: event.data } }),\n                                'ponyfillTTS', 'ponyfillASR'],\n                            target: 'idle'\n                        },\n                        onError: {\n                            target: 'fail'\n                        }\n                    }\n                },\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    },\n                },\n                recognising: {\n                    initial: 'noinput',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    invoke: {\n                        id: 'asrService',\n                        src: (context, _event) => (callback, _onReceive) => {\n\n                        }\n                    },\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => {\n                                    return {\n                                        recResult: event.value\n                                    }\n                                })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                    },\n                    states: {\n                        noinput: {\n                            entry: send(\n                                { type: 'TIMEOUT' },\n                                { delay: (context) => (1000 * (defaultPassivity || context.tdmPassivity)), id: 'timeout' }\n                            ),\n                            on: {\n                                TIMEOUT: '#root.asrtts.idle',\n                                STARTSPEECH: 'inprogress'\n                            },\n                            exit: cancel('timeout')\n                        },\n                        inprogress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    invoke: {\n                        id: 'ttsStart',\n                        src: (context, _event) => (callback, _onReceive) => {\n                            const utterance = new context.ttsUtterance(context.ttsAgenda);\n                            const voices = context.tts.getVoices();\n                            let voiceRe = RegExp(\"en-US\", 'u')\n                            if (process.env.REACT_APP_TTS_VOICE) {\n                                voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                            }\n                            const voice = voices.find(v => voiceRe.test(v.name))!\n                            if (voice) {\n                                utterance.voice = voice\n                                utterance.onend = () => callback('ENDSPEECH')\n                                console.log(`${utterance.voice.name} is speaking`);\n                                context.tts.speak(utterance)\n                            }\n                            else {\n                                console.error(`TTS_ERROR: Could not get voice for regexp ${voiceRe}`)\n                                callback('TTS_ERROR')\n                            }\n                        }\n                    },\n                    on: {\n                        ENDSPEECH: 'idle',\n                        TTS_ERROR: 'fail'\n                    }\n                    /* entry: 'ttsStart',\n                     * on: {\n                     *     ENDSPEECH: 'idle',\n                     * } */\n                },\n                fail: {}\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult[0][\"utterance\"]);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'fail' }) || props.state.matches({ dm: 'fail' }):\n            return (\n                <div className=\"control\">\n                    <div className=\"status\">Something went wrong...</div>\n                    <button type=\"button\" className=\"circle\"\n                        style={{}} {...props}>\n                    </button>\n                </div>);\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <div className=\"control\">\n                    <div className=\"status-talk\">talk</div>\n                    <button type=\"button\" className=\"circle\"\n                        style={{ animation: \"bordersize 2s infinite\" }} {...props}>\n                    </button>\n                </div>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <div className=\"control\">\n                    <div className=\"status\">speaking</div>\n                    <button type=\"button\" className=\"circle-speaking\"\n                        style={{ animation: \"bordering 2s infinite\" }} {...props}>\n                    </button>\n                </div>\n            );\n\n        case props.state.matches({ dm: 'init' }):\n            return (\n                <div className=\"control\" {...props}>\n                    <div className=\"status-talk\">click to start!</div>\n                    <button type=\"button\" className=\"circle-click\"\n                        style={{}}>\n                    </button>\n                </div>\n            );\n\n        default:\n            return (\n                <div className=\"control\">\n                    <div className=\"status-talk\"></div>\n                    <button type=\"button\" className=\"circle\"\n                        style={{}} {...props}>\n                    </button>\n                </div>\n            );\n    }\n}\n\n\nfunction App() {\n\n    const startListening = () => {\n        SpeechRecognition.startListening({\n            continuous: true,\n            language: process.env.REACT_APP_ASR_LANGUAGE || 'en-US'\n        });\n    }\n    const stopListening = () => {\n        SpeechRecognition.stopListening()\n    }\n\n\n    const [current, send] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a voice input.');\n                startListening()\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stopListening()\n            }),\n            ttsStart: asEffect((context) => {\n                const voices = context.tts.getVoices();\n                const utterance = new context.ttsUtterance(context.ttsAgenda);\n                let voiceRe = RegExp(\"en-US-AriaNeural\", 'u')\n                if (process.env.REACT_APP_TTS_VOICE) {\n                    voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                }\n                utterance.voice = voices.find(v => voiceRe.test(v.name))!\n                console.log(`${utterance.voice.name} is speaking`);\n                utterance.onend = () => send('ENDSPEECH')\n                context.tts.speak(utterance)\n            }),\n            ttsCancel: asEffect(() => {\n                console.log('TTS STOP...');\n                /* cancel() */\n                speechSynthesis.cancel()\n            }),\n            ponyfillTTS: asEffect((context, _event) => {\n                const ponyfill = createPonyfill({\n                    credentials: {\n                        region: REGION,\n                        authorizationToken: context.azureAuthorizationToken,\n                    }\n                });\n                const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;\n                context.tts = speechSynthesis\n                context.ttsUtterance = SpeechSynthesisUtterance\n            }),\n            ponyfillASR: asEffect((context, _event) => {\n                const\n                    { SpeechRecognition: AzureSpeechRecognition }\n                        = createSpeechRecognitionPonyfill({\n                            credentials: {\n                                region: REGION,\n                                authorizationToken: context.azureAuthorizationToken,\n                            }\n                        });\n                SpeechRecognition.applyPolyfill(AzureSpeechRecognition)\n                context.asr = SpeechRecognition.getRecognition()!\n                context.asr.onresult = function(event: any) {\n                    var result = event.results[0]\n                    if (result.isFinal) {\n                        send({\n                            type: \"ASRRESULT\", value:\n                                [{\n                                    \"utterance\": result[0].transcript,\n                                    \"confidence\": result[0].confidence\n                                }]\n                        })\n                    } else {\n                        send({ type: \"STARTSPEECH\" });\n                    }\n                }\n            })\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\nconst getAuthorizationToken = () => (\n    fetch(new Request(TOKEN_ENDPOINT, {\n        method: 'POST',\n        headers: {\n            'Ocp-Apim-Subscription-Key': process.env.REACT_APP_SUBSCRIPTION_KEY!\n        },\n    })).then(data => data.text()))\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n\n\n"],"sourceRoot":""}