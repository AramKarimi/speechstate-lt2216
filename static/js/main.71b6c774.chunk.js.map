{"version":3,"sources":["tdmClient.ts","jaicpClient.ts","dmColourChanger.ts","index.tsx"],"names":["send","actions","assign","choose","startSession","tdmRequest","requestBody","fetch","Request","process","method","headers","body","JSON","stringify","then","data","json","tdmAssign","sessionId","_ctx","event","session","session_id","tdmAll","tdmUtterance","output","utterance","tdmVisualOutputInfo","visual_output","visual_information","tdmExpectedAlternatives","context","expected_input","alternatives","tdmPassivity","expected_passivity","tdmActions","maybeAlternatives","cond","type","tdmDmMachine","initial","states","init","on","CLICK","tdm","start","invoke","id","src","_evt","onDone","target","onError","utter","RECOGNISED","SELECT","hapticInput","value","TIMEOUT","prompt","entry","ENDSPEECH","_evnt","some","item","name","ask","next","hypotheses","recResult","nextHaptic","expression","passivity","fail","sessionID","Math","random","toString","substr","sayColour","ttsAgenda","answer","say","text","_context","dmMachine","welcome","stop","always","repaint","dm","cancel","REGION","inspect","url","iframe","machine","Machine","gui","micOnly","SHOW_ALTERNATIVES","showAlternatives","asrtts","audioCtx","window","AudioContext","webkitAudioContext","navigator","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","getToken","getAuthorizationToken","azureAuthorizationToken","ponyfillTTS","_event","callback","_onReceive","ponyfill","createSpeechSynthesisPonyfill","audioContext","credentials","region","authorizationToken","speechSynthesis","SpeechSynthesisUtterance","tts","ttsUtterance","addEventListener","voices","getVoices","voiceRe","RegExp","voice","find","v","test","console","error","TTS_READY","TTS_ERROR","idle","LISTEN","SPEAK","recognising","exit","ASRRESULT","noinput","delay","STARTSPEECH","inprogress","match","pause","speaking","recLogResult","log","logIntent","nluData","intent","ReactiveButton","props","promptText","state","el","attribute","promptImage","circleClass","matches","className","alt","style","FigureButton","caption","alternative","imageSrc","App","useMachine","devTools","recStart","asEffect","asr","recStop","abort","ttsStart","onend","speak","ttsStop","ponyfillASR","SpeechRecognition","createSpeechRecognitionPonyfill","lang","continuous","interimResults","onresult","result","results","isFinal","transcript","confidence","current","figureButtons","filter","o","map","i","onClick","semantic_expression","rootElement","document","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.71b6c774.chunk.js","sourcesContent":["import { MachineConfig, actions, AssignAction } from \"xstate\";\n\nconst { send, assign, choose } = actions;\n\n\nconst tdmEndpoint = process.env.REACT_APP_TDM_ENDPOINT || \"https://sourdough-for-dummies-orchestration-pipeline.eu2.ddd.tala.cloud/interact\"\nconst tdmSession = {\n    \"session\": {\n        \"my_frontend\": {\n            \"user_id\": \"speechstate\",\n            \"position\": {\n                \"latitude\": \"57.699188\",\n                \"longitude\": \"11.948313\"\n            }\n        }\n    }\n}\n\nconst startSession = {\n    \"version\": \"3.3\",\n    \"session\": tdmSession,\n    \"request\": {\n        \"start_session\": {}\n    }\n}\n\nconst passivity = (sessionId: string) => ({\n    \"version\": \"3.3\",\n    \"session\": { \"session_id\": sessionId },\n    \"request\": {\n        \"passivity\": {}\n    }\n})\n\nconst nlInput = (sessionId: string, hypotheses: Hypothesis[]) => ({\n    \"version\": \"3.3\",\n    \"session\": { \"session_id\": sessionId },\n    \"request\": {\n        \"natural_language_input\": {\n            \"modality\": \"speech\",\n            \"hypotheses\": hypotheses\n        }\n    }\n})\n\nconst hapticInput = (sessionId: string, expression: string) => ({\n    \"version\": \"3.3\",\n    \"session\": { \"session_id\": sessionId },\n    \"request\": {\n        \"semantic_input\": {\n            \"interpretations\": [{\n                \"modality\": \"haptic\",\n                \"moves\": [{\n                    \"perception_confidence\": 1,\n                    \"understanding_confidence\": 1,\n                    \"semantic_expression\": expression\n                }]\n            }]\n        }\n    }\n})\n\nconst tdmRequest = (requestBody: any) => (fetch(new Request(tdmEndpoint, {\n    method: 'POST',\n    headers: {\n        'Content-type': 'application/json'\n    },\n    body: JSON.stringify(requestBody)\n})).then(data => data.json()))\n\nconst tdmAssign: AssignAction<SDSContext, any> = assign({\n    sessionId: (_ctx, event) => event.data.session.session_id,\n    tdmAll: (_ctx, event) => event.data,\n    tdmUtterance: (_ctx, event) => event.data.output.utterance,\n    tdmVisualOutputInfo: (_ctx, event) => (event.data.output.visual_output || [{}])[0].visual_information,\n    tdmExpectedAlternatives: (_ctx, event) => (event.data.context.expected_input || {}).alternatives,\n    tdmPassivity: (_ctx, event) => event.data.output.expected_passivity,\n    tdmActions: (_ctx, event) => event.data.output.actions,\n})\n\n\nconst maybeAlternatives = choose<SDSContext, SDSEvent>([\n    {\n        cond: (context) => { return (context.tdmExpectedAlternatives || [{}])[0].visual_information },\n        actions: [send({ type: \"SHOW_ALTERNATIVES\" })]\n    },\n])\n\nexport const tdmDmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'tdm'\n            }\n        },\n        tdm: {\n            initial: 'start',\n            states: {\n                start: {\n                    invoke: {\n                        id: \"startSession\",\n                        src: (_ctx, _evt) => tdmRequest(startSession),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions: tdmAssign,\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n                },\n                utter: {\n                    initial: 'prompt',\n                    on: {\n                        RECOGNISED: 'next',\n                        SELECT: {\n                            target: 'nextHaptic',\n                            actions: assign({ hapticInput: (_ctx, event) => event.value })\n                        },\n                        TIMEOUT: 'passivity'\n                    },\n                    states: {\n                        prompt: {\n                            entry: [\n                                maybeAlternatives,\n                                send((context: SDSContext) => ({\n                                    type: \"SPEAK\", value: context.tdmUtterance\n                                }))],\n                            on: {\n                                ENDSPEECH:\n                                    [\n                                        {\n                                            target: '#root.dm.init',\n                                            cond: (context, _evnt) => context.tdmActions.some((item: any) => item.name === 'EndSession')\n                                        },\n                                        { target: 'ask' }\n                                    ]\n\n                            }\n                        },\n                        ask: {\n                            entry: send('LISTEN')\n                        },\n                    }\n                },\n                next: {\n                    invoke: {\n                        id: \"nlInput\",\n                        src: (context, _evt) => tdmRequest(nlInput(context.sessionId, context.recResult)),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions: tdmAssign,\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n                },\n                nextHaptic: {\n                    invoke: {\n                        id: \"hapticInput\",\n                        src: (context, _evt) => tdmRequest(hapticInput(context.sessionId, context.hapticInput)),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions: tdmAssign,\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n                },\n                passivity: {\n                    invoke: {\n                        id: \"passivity\",\n                        src: (context, _evt) => tdmRequest(passivity(context.sessionId)),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions: tdmAssign,\n                                cond: (_ctx, event) => event.data.output\n                            },\n                            {\n                                target: 'fail'\n                            }\n                        ],\n                        onError: { target: 'fail' }\n                    }\n\n                },\n                fail: {}\n            },\n        },\n    },\n});\n","import { MachineConfig, send, assign } from \"xstate\";\n\nconst jaicpToken = 'NRBTzSQe:69ae9a334ee112ff9a006af3639ed243ec38e431'\nconst jaicpEndpoint = \"https://bot.jaicp.com/chatapi/\" + jaicpToken\n\nconst ID = function() {\n    // Math.random should be unique because of its seeding algorithm.\n    // Convert it to base 36 (numbers + letters), and grab the first 9 characters\n    // after the decimal. from https://gist.github.com/gordonbrander/2230317\n    return '_' + Math.random().toString(36).substr(2, 9);\n};\n\nconst sessionID = ID()\n\nconst jaicpRequest = (query: string) => (fetch(new Request(jaicpEndpoint, {\n    method: 'POST',\n    headers: {\n        'Content-type': 'application/json'\n    },\n    body: JSON.stringify({\n        \"clientId\": \"speechstate_\" + sessionID,\n        \"query\": query,\n    })\n})).then(data => data.json()))\n\n\nexport const jaicpDmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            entry: assign({\n                ttsAgenda: (_ctx, event) => \"Привет! Спроси меня что-нибудь.\"\n            }),\n            on: {\n                CLICK: 'jaicp'\n            }\n        },\n        jaicp: {\n            initial: 'utter',\n            states: {\n                utter: {\n                    initial: 'prompt',\n                    states: {\n                        prompt: {\n                            entry: send((context: SDSContext) => ({\n                                type: \"SPEAK\", value: context.ttsAgenda\n                            })),\n                            on: { ENDSPEECH: 'ask' },\n                        },\n                        ask: {\n                            entry: send('LISTEN')\n                        },\n                    },\n                    on: {\n                        RECOGNISED: 'next',\n                        // TIMEOUT: 'passivity'\n                    },\n                },\n                next: {\n                    invoke: {\n                        id: \"nlInput\",\n                        src: (context, _evt) => jaicpRequest(context.recResult[0].utterance),\n                        onDone: [\n                            {\n                                target: 'utter',\n                                actions:\n                                    assign({\n                                        ttsAgenda: (_ctx, event) => event.data.data.answer,\n                                    }),\n                                cond: (_ctx, event) => event.data.data.answer !== \"\"\n                            },\n                            {\n                                target: '#root.dm.fail'\n                            }\n                        ],\n                        onError: { target: '#root.dm.fail' }\n                    }\n\n                },\n            },\n        },\n        fail: {}\n    },\n});\n","import { MachineConfig, send, Action } from \"xstate\";\n\n\nconst sayColour: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: `Repainting to ${context.recResult[0].utterance}`\n}))\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            initial: 'prompt',\n            on: {\n                RECOGNISED: [\n                    // { target: 'stop', cond: (context) => context.recResult === 'stop' },\n                    { target: 'repaint' }]\n            },\n            states: {\n                prompt: {\n                    entry: say(\"Tell me the colour\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {\n                    entry: send('LISTEN'),\n                },\n            }\n        },\n        stop: {\n            entry: say(\"Ok\"),\n            always: 'init'\n        },\n        repaint: {\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: sayColour,\n                    on: { ENDSPEECH: 'repaint' }\n                },\n                repaint: {\n                    entry: 'changeColour',\n                    always: '#root.dm.welcome'\n                }\n            }\n        }\n    }\n})\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, actions, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { tdmDmMachine } from \"./tdmClient\";\nimport { jaicpDmMachine } from \"./jaicpClient\";\nimport { dmMachine } from \"./dmColourChanger\";\n\nimport createSpeechRecognitionPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/SpeechToText'\nimport createSpeechSynthesisPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/TextToSpeech';\n\nlet dm = dmMachine\nif (process.env.REACT_APP_BACKEND === 'TDM') {\n    dm = tdmDmMachine\n} else if (process.env.REACT_APP_BACKEND === 'JAICP') {\n    dm = jaicpDmMachine\n}\n\n\nconst { send, cancel } = actions\n\nconst TOKEN_ENDPOINT = 'https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken';\nconst REGION = 'northeurope';\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nconst defaultPassivity = 10\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dm\n        },\n\n        gui: {\n            initial: 'micOnly',\n            states: {\n                micOnly: {\n                    on: { SHOW_ALTERNATIVES: 'showAlternatives' },\n                },\n                showAlternatives: {\n                    on: { SELECT: 'micOnly' },\n                }\n            }\n        },\n\n        asrtts: {\n            initial: 'init',\n            states: {\n                init: {\n                    on: {\n                        CLICK: {\n                            target: 'getToken',\n                            actions: [\n                                assign({\n                                    audioCtx: (_ctx) =>\n                                        new ((window as any).AudioContext || (window as any).webkitAudioContext)()\n                                }),\n                                (context) =>\n                                    navigator.mediaDevices.getUserMedia({ audio: true })\n                                        .then(function(stream) { context.audioCtx.createMediaStreamSource(stream) })\n                            ]\n                        }\n                    }\n                },\n                getToken: {\n                    invoke: {\n                        id: \"getAuthorizationToken\",\n                        src: (_ctx, _evt) => getAuthorizationToken(),\n                        onDone: {\n                            actions: [\n                                assign((_context, event) => { return { azureAuthorizationToken: event.data } }),\n                                'ponyfillASR'],\n                            target: 'ponyfillTTS'\n                        },\n                        onError: {\n                            target: 'fail'\n                        }\n                    }\n                },\n                ponyfillTTS: {\n                    invoke: {\n                        id: 'ponyTTS',\n                        src: (context, _event) => (callback, _onReceive) => {\n                            const ponyfill = createSpeechSynthesisPonyfill({\n                                audioContext: context.audioCtx,\n                                credentials: {\n                                    region: REGION,\n                                    authorizationToken: context.azureAuthorizationToken,\n                                }\n                            });\n                            const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;\n                            context.tts = speechSynthesis\n                            context.ttsUtterance = SpeechSynthesisUtterance\n                            context.tts.addEventListener('voiceschanged', () => {\n                                context.tts.cancel()\n                                const voices = context.tts.getVoices();\n                                let voiceRe = RegExp(\"en-US\", 'u')\n                                if (process.env.REACT_APP_TTS_VOICE) {\n                                    voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                                }\n                                const voice = voices.find((v: any) => voiceRe.test(v.name))!\n                                if (voice) {\n                                    context.voice = voice\n                                    callback('TTS_READY')\n                                } else {\n                                    console.error(`TTS_ERROR: Could not get voice for regexp ${voiceRe}`)\n                                    callback('TTS_ERROR')\n                                }\n                            })\n                        }\n                    },\n                    on: {\n                        TTS_READY: 'idle',\n                        TTS_ERROR: 'fail'\n                    }\n                },\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    },\n                },\n                recognising: {\n                    initial: 'noinput',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => {\n                                    return {\n                                        recResult: event.value\n                                    }\n                                })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        SELECT: 'idle',\n                        CLICK: '.pause'\n                    },\n                    states: {\n                        noinput: {\n                            entry: [\n                                'recStart',\n                                send(\n                                    { type: 'TIMEOUT' },\n                                    { delay: (context) => (1000 * (context.tdmPassivity || defaultPassivity)), id: 'timeout' }\n                                )],\n                            on: {\n                                TIMEOUT: '#root.asrtts.idle',\n                                STARTSPEECH: 'inprogress'\n                            },\n                            exit: cancel('timeout')\n                        },\n                        inprogress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                        pause: {\n                            entry: 'recStop',\n                            on: { CLICK: 'noinput' }\n                        }\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                        SELECT: 'idle',\n                        CLICK: { target: 'idle', actions: send('ENDSPEECH') }\n                    },\n                    exit: 'ttsStop',\n                },\n                fail: {}\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('U>', context.recResult[0][\"utterance\"], context.recResult[0][\"confidence\"]);\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n    alternative: any;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    var promptText = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"name\") || {}).value;\n    var promptImage = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"image\") || {}).value;\n    var circleClass = \"circle\"\n    switch (true) {\n        case props.state.matches({ asrtts: 'fail' }) || props.state.matches({ dm: 'fail' }):\n            break;\n        case props.state.matches({ asrtts: { recognising: 'pause' } }):\n            promptText = \"Click to continue\"\n            break;\n        case props.state.matches({ asrtts: 'recognising' }):\n            circleClass = \"circle-recognising\"\n            promptText = promptText || 'Listening...'\n            break;\n        case props.state.matches({ asrtts: 'speaking' }):\n            circleClass = \"circle-speaking\"\n            promptText = promptText || 'Speaking...'\n            break;\n        case props.state.matches({ dm: 'init' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        default:\n            promptText = promptText || '\\u00A0'\n    }\n    return (\n        <div className=\"control\">\n            <figure className=\"prompt\">\n                {promptImage &&\n                    <img src={promptImage}\n                        alt={promptText} />}\n            </figure>\n            <div className=\"status\">\n                <button type=\"button\" className={circleClass}\n                    style={{}} {...props}>\n                </button>\n                <div className=\"status-text\">\n                    {promptText}\n                </div>\n            </div>\n        </div>);\n}\n\nconst FigureButton = (props: Props): JSX.Element => {\n    const caption = props.alternative.find((el: any) => el.attribute === \"name\").value\n    const imageSrc = (props.alternative.find((el: any) => el.attribute === \"image\") || {}).value\n    return (\n        <figure className=\"flex\" {...props}>\n            {imageSrc &&\n                <img src={imageSrc} alt={caption} />}\n            <figcaption>{caption}</figcaption>\n        </figure>\n    )\n}\n\nfunction App() {\n    const [current, send] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect((context) => {\n                context.asr.start()\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n            recStop: asEffect((context) => {\n                context.asr.abort()\n                /* console.log('Recognition stopped.'); */\n            }),\n            ttsStart: asEffect((context) => {\n                const utterance = new context.ttsUtterance(context.ttsAgenda);\n                console.log(\"S>\", context.ttsAgenda)\n                utterance.voice = context.voice\n                utterance.onend = () => send('ENDSPEECH')\n                context.tts.speak(utterance)\n            }),\n            ttsStop: asEffect((context) => {\n                /* console.log('TTS STOP...'); */\n                context.tts.cancel()\n            }),\n            ponyfillASR: asEffect((context, _event) => {\n                const\n                    { SpeechRecognition }\n                        = createSpeechRecognitionPonyfill({\n                            audioContext: context.audioCtx,\n                            credentials: {\n                                region: REGION,\n                                authorizationToken: context.azureAuthorizationToken,\n                            }\n                        });\n                context.asr = new SpeechRecognition()\n                context.asr.lang = process.env.REACT_APP_ASR_LANGUAGE || 'en-US'\n                context.asr.continuous = true\n                context.asr.interimResults = true\n                context.asr.onresult = function(event: any) {\n                    var result = event.results[0]\n                    if (result.isFinal) {\n                        send({\n                            type: \"ASRRESULT\", value:\n                                [{\n                                    \"utterance\": result[0].transcript,\n                                    \"confidence\": result[0].confidence\n                                }]\n                        })\n                    } else {\n                        send({ type: \"STARTSPEECH\" });\n                    }\n                }\n\n            })\n        }\n    });\n    const figureButtons = (current.context.tdmExpectedAlternatives || []).filter((o: any) => o.visual_information)\n        .map(\n            (o: any, i: any) => (\n                <FigureButton state={current}\n                    alternative={o.visual_information}\n                    key={i}\n                    onClick={() => send({ type: 'SELECT', value: o.semantic_expression })} />\n            )\n        )\n\n    switch (true) {\n        default:\n            return (\n                <div className=\"App\">\n                    <ReactiveButton state={current} alternative={{}} onClick={() => send('CLICK')} />\n                    <div className=\"select-wrapper\">\n                        <div className=\"select\">\n                            {figureButtons}\n                        </div>\n                    </div>\n                </div>\n            )\n    }\n\n};\n\nconst getAuthorizationToken = () => (\n    fetch(new Request(TOKEN_ENDPOINT, {\n        method: 'POST',\n        headers: {\n            'Ocp-Apim-Subscription-Key': process.env.REACT_APP_SUBSCRIPTION_KEY!\n        },\n    })).then(data => data.text()))\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}